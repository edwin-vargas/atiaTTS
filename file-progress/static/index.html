<!DOCTYPE html>
<html>
<head>
    <title>Actix Web TTS</title>
    <style>
        body { font-family: sans-serif; padding: 20px; display: flex; gap: 30px; }
        .column { flex: 1; }
        #status { margin-bottom: 15px; font-weight: bold; min-height: 1.2em; background-color: #f0f0f0; padding: 5px;}
        #serverMessages { margin-top: 15px; max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; }
        #serverMessages li { background-color: #eee; margin-bottom: 3px; padding: 2px 5px; font-size: 0.9em; word-wrap: break-word; }
        #serverMessages li.error { background-color: #f8d7da; color: #721c24; }
        #serverMessages li.success { background-color: #d4edda; color: #155724; }
        #serverMessages li.info { background-color: #e2e3e5; color: #383d41; }
        #serverMessages li.progress-msg { background-color: #cce5ff; color: #004085; }

        #jobs { margin-top: 15px; }
        .job-item { border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; background-color: #f9f9f9; }
        .job-item h4 { margin: 0 0 5px 0; }
        .job-item p { margin: 3px 0; font-size: 0.9em; }
        .job-item progress { width: 100%; height: 10px; }
        .job-item a {
            display: inline-block;
            margin-top: 5px;
            padding: 5px 10px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9em;
        }
         .job-item a:hover { background-color: #218838; }
         .job-item a.disabled { background-color: #ccc; cursor: not-allowed; }

        label { display: block; margin-bottom: 5px; font-weight: bold;}
        input[type="file"], textarea, button { margin-bottom: 10px; padding: 8px; }
        textarea { width: 95%; min-height: 100px; }
        button { cursor: pointer; }
        button:disabled { cursor: not-allowed; background-color: #ccc; }
    </style>
</head>
<body>
    <div class="column">
        <h1>Text-to-Speech Converter</h1>
        <div id="status">Connecting to WebSocket...</div>

        <div id="ttsFromString">
            <h2>Convert Text String</h2>
            <label for="textInput">Enter Text:</label>
            <textarea id="textInput" placeholder="Type or paste text here..."></textarea>
            <button id="sendTextButton" disabled>Convert Text to Speech</button>
        </div>

        <div id="ttsFromFile">
            <h2>Convert Text File</h2>
            <label for="fileInput">Select .txt File:</label>
            <input type="file" id="fileInput" accept=".txt"> <!-- Aceptar solo .txt -->
            <button id="uploadAndConvertButton" disabled>Upload & Convert File</button>
             <!-- Nota: La subida múltiple no está implementada aquí, requeriría cambios significativos -->
        </div>

        <div id="serverMessages">
            <h2>Log Messages:</h2>
            <ul id="messageList"></ul>
        </div>
    </div>

    <div class="column">
        <h2>Conversion Jobs</h2>
        <div id="jobs">
            <!-- Job status will be displayed here -->
        </div>
    </div>


    <script>
        const statusDiv = document.getElementById('status');
        const messageList = document.getElementById('messageList');
        const jobsDiv = document.getElementById('jobs');

        // --- Text Input Elements ---
        const textInput = document.getElementById('textInput');
        const sendTextButton = document.getElementById('sendTextButton');

        // --- File Input Elements ---
        const fileInput = document.getElementById('fileInput');
        const uploadAndConvertButton = document.getElementById('uploadAndConvertButton');

        let websocket = null;
        let selectedFile = null;
        // Almacenar información sobre los uploads pendientes (frágil, ver comentarios en Rust)
        // let pendingUploadInfo = null; // { fileId, filename }

        // --- WebSocket Connection ---
        function connectWebSocket() {
            // Asegurarse de cerrar conexión previa si existe
            if (websocket) {
                websocket.close();
            }

            const wsUrl = `ws://${window.location.host}/ws`;
            websocket = new WebSocket(wsUrl);

            websocket.onopen = () => {
                statusDiv.textContent = 'WebSocket Connected';
                statusDiv.style.backgroundColor = '#d4edda';
                sendTextButton.disabled = false;
                uploadAndConvertButton.disabled = (selectedFile === null);
                logMessage('WebSocket connection established.', 'info');
            };

            websocket.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    // console.debug('Raw message from server:', event.data);
                    try {
                        const message = JSON.parse(event.data);
                        handleServerMessage(message);
                    } catch (e) {
                        logMessage(`Error parsing server message: ${e}`, 'error');
                        logMessage(`Raw data: ${event.data}`, 'error');
                    }
                } else {
                     logMessage('Received unexpected binary data from server.', 'error');
                }
            };

            websocket.onerror = (error) => {
                statusDiv.textContent = 'WebSocket Error!';
                statusDiv.style.backgroundColor = '#f8d7da';
                console.error('WebSocket Error:', error);
                logMessage('WebSocket Error. Check console.', 'error');
                disableButtons();
            };

            websocket.onclose = (event) => {
                statusDiv.textContent = 'WebSocket Closed. Attempting to reconnect...';
                statusDiv.style.backgroundColor = '#f8d7da';
                logMessage(`WebSocket Closed (Code: ${event.code}, Reason: ${event.reason || 'No reason given'}). Reconnecting in 5s...`, 'error');
                disableButtons();
                websocket = null;
                // Intentar reconectar después de un tiempo
                setTimeout(connectWebSocket, 5000);
            };
        }

        function disableButtons() {
            sendTextButton.disabled = true;
            uploadAndConvertButton.disabled = true;
        }

        // --- Message Handling ---
        function handleServerMessage(msg) {
            logMessage(`Received: ${JSON.stringify(msg)}`, getMsgClass(msg.type)); // Log raw message for debug

            switch (msg.type) {
                case 'info':
                    statusDiv.textContent = msg.message;
                    break;
                case 'error':
                    statusDiv.textContent = `Error: ${msg.message}`;
                    statusDiv.style.backgroundColor = '#f8d7da';
                    if (msg.job_id) {
                        updateJobStatus(msg.job_id, { status: 'Error', message: msg.message, progress: 0 });
                    }
                    break;
                // --- Upload Flow (Simplificado, ASUME que el binario sigue al StartUpload) ---
                // ESTA PARTE NECESITA REVISIÓN PROFUNDA PARA SER ROBUSTA
                case 'upload_ready':
                    // El servidor está listo para el binario. El servidor generó file_id.
                    // Necesitamos almacenar esto para enviarlo luego con `start_tts_file`.
                    // Esta forma es FRÁGIL si hay múltiples uploads o retrasos.
                    // Guardamos la info para usarla DESPUÉS de enviar el binario.
                     logMessage(`Server ready for file '${msg.filename}'. File ID: ${msg.file_id}. Now sending binary data...`, 'info');
                    // pendingUploadInfo = { fileId: msg.file_id, filename: msg.filename };
                    // Ahora enviamos el binario (ver sendFile)
                     sendFileData(selectedFile, msg.file_id, msg.filename); // Pasamos el file_id/filename aquí
                    break;
                case 'upload_complete':
                    // El servidor confirma que recibió el archivo completo.
                    logMessage(`File '${msg.filename}' (ID: ${msg.file_id}) uploaded successfully.`, 'success');
                    statusDiv.textContent = `File '${msg.filename}' uploaded. Ready to convert.`;
                     // ¡Ahora podemos iniciar la conversión para este archivo!
                    // O podríamos dejar que el usuario haga clic en un botón "Convert this uploaded file"
                    // Para este ejemplo, iniciamos la conversión automáticamente:
                    if (confirm(`File '${msg.filename}' uploaded. Start TTS conversion now?`)) {
                         requestTtsForFile(msg.file_id, msg.filename);
                    } else {
                        // Re-enable upload button if user cancels conversion
                        uploadAndConvertButton.disabled = (selectedFile === null);
                    }
                    break;
                // --- TTS Flow ---
                case 'tts_job_created':
                    statusDiv.textContent = `TTS Job ${msg.job_id} created...`;
                    createOrUpdateJobEntry(msg.job_id, msg.original_filename || `String Input`, msg.original_file_id);
                    updateJobStatus(msg.job_id, { status: 'Queued', message: 'Waiting to process...', progress: 0 });
                    break;
                case 'tts_progress':
                    statusDiv.textContent = `Job ${msg.job_id}: ${msg.message} (${(msg.progress * 100).toFixed(1)}%)`;
                    updateJobStatus(msg.job_id, { status: 'Processing', message: msg.message, progress: msg.progress });
                    break;
                case 'tts_complete':
                    statusDiv.textContent = `Job ${msg.job_id} Complete!`;
                    statusDiv.style.backgroundColor = '#d4edda';
                    updateJobStatus(msg.job_id, {
                        status: 'Complete',
                        message: `Audio '${msg.filename}' ready.`,
                        progress: 1,
                        downloadUrl: msg.download_url,
                        downloadFilename: msg.filename
                    });
                    // Re-enable buttons after successful job
                    sendTextButton.disabled = false;
                    uploadAndConvertButton.disabled = (selectedFile === null);
                    break;
                default:
                    logMessage(`Received unknown message type: ${msg.type}`, 'warning');
            }
        }

        function getMsgClass(type) {
             if (type === 'error') return 'error';
             if (type === 'success' || type === 'upload_complete' || type === 'tts_complete') return 'success';
             if (type === 'info' || type === 'upload_ready' || type === 'tts_job_created') return 'info';
             if (type === 'tts_progress') return 'progress-msg';
             return ''; // Default
        }

        function logMessage(message, type = '') {
            const li = document.createElement('li');
            li.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (type) {
                li.classList.add(type);
            }
            // messageList.appendChild(li);
            messageList.insertBefore(li, messageList.firstChild); // Add to top
            // Optional: Limit the number of log messages
            if (messageList.children.length > 100) {
                messageList.removeChild(messageList.lastChild);
            }
        }

        // --- Job Status UI ---
        function createOrUpdateJobEntry(jobId, description, fileId = null) {
            let jobDiv = document.getElementById(`job-${jobId}`);
            if (!jobDiv) {
                jobDiv = document.createElement('div');
                jobDiv.id = `job-${jobId}`;
                jobDiv.classList.add('job-item');
                jobDiv.innerHTML = `
                    <h4>Job: ${jobId.substring(0, 8)}...</h4>
                    <p><strong>Source:</strong> ${description}</p>
                    ${fileId ? `<p><em>File ID: ${fileId}</em></p>` : ''}
                    <p class="status">Status: Initializing...</p>
                    <progress value="0" max="1"></progress>
                    <p class="message"></p>
                    <div class="download-area"></div>
                `;
                // jobsDiv.appendChild(jobDiv);
                jobsDiv.insertBefore(jobDiv, jobsDiv.firstChild); // Add new jobs at the top
            }
            return jobDiv;
        }

        function updateJobStatus(jobId, data) {
            // data = { status, message, progress, downloadUrl?, downloadFilename? }
            const jobDiv = document.getElementById(`job-${jobId}`);
            if (!jobDiv) {
                logMessage(`Cannot update UI for unknown job ID: ${jobId}`, 'error');
                return;
            }

            jobDiv.querySelector('.status').textContent = `Status: ${data.status}`;
            jobDiv.querySelector('.message').textContent = data.message || '';

            const progressBar = jobDiv.querySelector('progress');
            if (progressBar) {
                progressBar.value = data.progress;
            }

            const downloadArea = jobDiv.querySelector('.download-area');
            downloadArea.innerHTML = ''; // Clear previous link

            if (data.downloadUrl && data.downloadFilename) {
                const link = document.createElement('a');
                link.href = data.downloadUrl;
                // El servidor establece Content-Disposition, no necesitamos 'download' attribute aquí.
                // link.download = data.downloadFilename;
                link.textContent = `Download ${data.downloadFilename}`;
                link.target = "_blank"; // Open in new tab/window context
                downloadArea.appendChild(link);
            } else if (data.status === 'Complete' && !data.downloadUrl) {
                 downloadArea.textContent = 'Download link not available.';
            }
        }


        // --- Sending Messages ---
        function sendWsMessage(messageObject) {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                logMessage('WebSocket is not connected. Cannot send message.', 'error');
                statusDiv.textContent = 'WebSocket disconnected. Please wait for reconnection.';
                statusDiv.style.backgroundColor = '#f8d7da';
                disableButtons();
                return false;
            }
            try {
                const jsonMessage = JSON.stringify(messageObject);
                websocket.send(jsonMessage);
                logMessage(`Sent: ${jsonMessage}`, 'info');
                return true;
            } catch (e) {
                logMessage(`Failed to stringify or send message: ${e}`, 'error');
                return false;
            }
        }

        // --- Actions ---
        sendTextButton.onclick = () => {
            const text = textInput.value.trim();
            if (!text) {
                alert('Please enter some text to convert.');
                return;
            }
            sendTextButton.disabled = true; // Disable during processing
            statusDiv.textContent = 'Sending text for TTS conversion...';
            if (!sendWsMessage({
                type: 'start_tts_string',
                text: text,
                // TODO: Add options from UI elements (language, format, etc.)
                language: null,
                format: null
            })) {
                // Re-enable button if sending failed immediately
                sendTextButton.disabled = false;
            } else {
                 textInput.value = ''; // Clear input after sending
            }
        };

        fileInput.onchange = (event) => {
            selectedFile = event.target.files[0];
            if (selectedFile && websocket && websocket.readyState === WebSocket.OPEN) {
                 if (!selectedFile.type || selectedFile.type !== 'text/plain') {
                    alert('Please select a plain text file (.txt)');
                    fileInput.value = ''; // Reset input
                    selectedFile = null;
                    uploadAndConvertButton.disabled = true;
                    return;
                 }
                statusDiv.textContent = `File selected: ${selectedFile.name}`;
                uploadAndConvertButton.disabled = false;
            } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 statusDiv.textContent = 'WebSocket not connected. Cannot select file yet.';
                 uploadAndConvertButton.disabled = true;
                 selectedFile = null;
                 fileInput.value = '';
            } else {
                selectedFile = null;
                statusDiv.textContent = 'No file selected or invalid file type.';
                uploadAndConvertButton.disabled = true;
            }
        };

        // Combines upload request and triggering the binary send
        uploadAndConvertButton.onclick = () => {
            if (!selectedFile) {
                alert('Please select a text file first.');
                return;
            }
            uploadAndConvertButton.disabled = true; // Disable during upload/conversion
            statusDiv.textContent = `Initiating upload for ${selectedFile.name}...`;

            // 1. Tell the server we *want* to upload this file
            // The server will respond with 'upload_ready' containing the file_id
             if (!sendWsMessage({
                 type: 'start_upload',
                 filename: selectedFile.name
             })) {
                 // Re-enable button if sending failed
                 uploadAndConvertButton.disabled = false;
                 statusDiv.textContent = 'Failed to initiate upload. WebSocket issue?';
             }
            // The actual binary sending happens in sendFileData, triggered by 'upload_ready' message
        };

        // Function to send the actual file data (called after 'upload_ready')
        function sendFileData(file, fileId, filename) {
             if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                logMessage(`Cannot send binary data for ${filename}, WebSocket closed.`, 'error');
                updateJobStatus(null, { status: 'Error', message: 'WebSocket closed during upload.', progress: 0}, fileId); // Update based on fileId if possible
                uploadAndConvertButton.disabled = (selectedFile === null); // Re-enable maybe
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                websocket.send(e.target.result); // Send raw ArrayBuffer
                logMessage(`Sent ${e.target.result.byteLength} bytes of binary data for '${filename}' (ID: ${fileId}). Waiting for server confirmation...`, 'info');
                statusDiv.textContent = `Sent ${filename}. Waiting for server confirmation...`;
                // DO NOT trigger TTS here. Wait for 'upload_complete' from server.
            };
            reader.onerror = (e) => {
                 logMessage(`FileReader error for ${filename}: ${e}`, 'error');
                 statusDiv.textContent = `Error reading file: ${filename}`;
                 updateJobStatus(null, { status: 'Error', message: 'Failed to read file locally.', progress: 0 }, fileId);
                 uploadAndConvertButton.disabled = (selectedFile === null); // Re-enable
            }
            reader.readAsArrayBuffer(file);
        }

         // Function to request TTS for an already uploaded file
        function requestTtsForFile(fileId, filename) {
            logMessage(`Requesting TTS conversion for file '${filename}' (ID: ${fileId})...`, 'info');
            statusDiv.textContent = `Requesting TTS for ${filename}...`;
             if (!sendWsMessage({
                 type: 'start_tts_file',
                 file_id: fileId,
                 filename: filename,
                 // TODO: Add options from UI
                 language: null,
                 format: null
             })) {
                  statusDiv.textContent = `Failed to request TTS for ${filename}.`;
                  // Re-enable upload button if the request failed immediately
                  uploadAndConvertButton.disabled = (selectedFile === null);
             }
        }


        // --- Initial connection ---
        connectWebSocket();

    </script>
</body>
</html>