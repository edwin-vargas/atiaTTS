<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Text-to-Speech (espeak)</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #drop-area { border: 2px dashed #ccc; border-radius: 10px; padding: 20px; text-align: center; margin-bottom: 15px; }
        #drop-area.highlight { border-color: purple; }
        #file-list { margin-bottom: 15px; }
        #audio-outputs { margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px; }
        .audio-item { margin-bottom: 10px; padding: 5px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;}
        .audio-item p { margin: 0 0 5px 0; font-weight: bold; }
        .error { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>WebSocket Text-to-Speech (con espeak)</h1>

    <div id="status">Desconectado</div>

    <div id="drop-area">
        <p>Arrastra archivos de texto (.txt) aquí o haz clic para seleccionar</p>
        <input type="file" id="fileElem" multiple accept=".txt" style="display: none;">
    </div>

    <div id="file-list">
        <strong>Archivos seleccionados:</strong>
        <ul id="selected-files-list"></ul>
    </div>

    <button id="sendButton" disabled>Conectar y Enviar Archivos</button>

    <div id="audio-outputs">
        <h2>Resultados de Audio:</h2>
        <div id="audios"></div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const dropArea = document.getElementById('drop-area');
        const fileElem = document.getElementById('fileElem');
        const sendButton = document.getElementById('sendButton');
        const audiosDiv = document.getElementById('audios');
        const selectedFilesList = document.getElementById('selected-files-list');

        let websocket = null;
        let selectedFiles = [];
        let nextAudioBlob = null; // Para almacenar temporalmente el blob de audio

        // --- Manejo de Drag & Drop ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false); // Prevenir si se suelta fuera
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.add('highlight'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, () => dropArea.classList.remove('highlight'), false);
        });

        dropArea.addEventListener('drop', handleDrop, false);
        dropArea.addEventListener('click', () => fileElem.click()); // Abrir selector al hacer clic
        fileElem.addEventListener('change', handleFileSelect, false);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFileSelect(e) {
            handleFiles(e.target.files);
        }

        function handleFiles(files) {
            selectedFiles = Array.from(files).filter(file => file.type === 'text/plain'); // Solo .txt
             updateSelectedFilesList();
            sendButton.disabled = selectedFiles.length === 0;
        }

         function updateSelectedFilesList() {
            selectedFilesList.innerHTML = ''; // Limpiar lista
            if (selectedFiles.length === 0) {
                selectedFilesList.innerHTML = '<li>Ningún archivo .txt seleccionado.</li>';
            } else {
                selectedFiles.forEach(file => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
                    selectedFilesList.appendChild(listItem);
                });
            }
        }

        // --- Lógica de WebSocket ---
        function connectAndSend() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                 console.log("Ya conectado, enviando archivos...");
                 sendFiles();
            } else {
                statusDiv.textContent = 'Conectando...';
                sendButton.disabled = true; // Deshabilitar mientras conecta/envía
                // Asegúrate que la URL coincida con tu servidor Rust
                const wsUrl = `ws://${window.location.host}/ws`;
                websocket = new WebSocket(wsUrl);

                websocket.onopen = () => {
                    statusDiv.textContent = 'Conectado';
                    console.log('WebSocket conectado.');
                    sendFiles(); // Enviar archivos una vez conectado
                };

                websocket.onmessage = (event) => {
                     console.log('Mensaje recibido:', event.data);
                    if (typeof event.data === 'string') {
                        // Esperamos mensajes de control tipo "type::filename"
                        if (event.data.startsWith('audio::')) {
                            // El *siguiente* mensaje binario será el audio para este archivo
                            const filename = event.data.substring(7); // Quita "audio::"
                            console.log(`Esperando blob de audio para: ${filename}`);
                            // Guardamos el nombre para usarlo cuando llegue el blob
                            nextAudioBlob = { expectedFilename: filename };
                        } else if (event.data.startsWith('error::')) {
                            const filename = event.data.substring(7);
                            console.error(`Error procesando ${filename} en el servidor.`);
                            displayError(filename);
                        }
                    } else if (event.data instanceof Blob) {
                         console.log('Blob de audio recibido.');
                        if (nextAudioBlob) {
                            // Tenemos un blob y esperábamos uno
                            const blob = event.data;
                            const filename = nextAudioBlob.expectedFilename;
                            nextAudioBlob = null; // Resetear para el siguiente

                            const audioUrl = URL.createObjectURL(blob);
                            displayAudio(filename, audioUrl);
                        } else {
                            console.warn("Recibido un Blob de audio inesperado.");
                        }
                    }
                };

                websocket.onerror = (error) => {
                    statusDiv.textContent = 'Error de Conexión';
                    console.error('WebSocket Error:', error);
                    sendButton.disabled = false; // Habilitar para reintentar?
                };

                websocket.onclose = (event) => {
                    statusDiv.textContent = `Desconectado: ${event.reason || 'Normal'}`;
                    console.log('WebSocket cerrado. Code:', event.code, 'Reason:', event.reason);
                    websocket = null;
                    sendButton.disabled = selectedFiles.length === 0; // Habilitar si hay archivos
                };
            }
        }

        function sendFiles() {
             if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 console.error("WebSocket no está conectado.");
                 statusDiv.textContent = 'Error: No conectado';
                 sendButton.disabled = selectedFiles.length === 0;
                 return;
             }
            statusDiv.textContent = 'Enviando archivos...';

            if (selectedFiles.length === 0) {
                console.log("No hay archivos seleccionados para enviar.");
                statusDiv.textContent = 'Conectado (sin archivos para enviar)';
                 sendButton.disabled = true; // Ya se enviaron o no había
                return;
            }

            selectedFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const fileContent = e.target.result;
                    // Formato: "nombreArchivo.txt::Contenido del archivo..."
                    const message = `${file.name}::${fileContent}`;
                    console.log(`Enviando: ${file.name}`);
                    websocket.send(message);
                };
                 reader.onerror = (e) => {
                     console.error(`Error leyendo el archivo ${file.name}:`, e);
                     displayError(file.name, "Error de lectura local");
                 }
                reader.readAsText(file); // Lee como texto plano
            });

            // Limpiar la selección después de enviar (o podrías mantenerla)
            // selectedFiles = [];
            // updateSelectedFilesList();
            statusDiv.textContent = 'Archivos enviados, esperando audio...';
            // Mantener el botón deshabilitado hasta que se seleccione algo nuevo o se desconecte
            sendButton.disabled = true;
        }

        function displayAudio(filename, audioUrl) {
            const audioItem = document.createElement('div');
            audioItem.classList.add('audio-item');

            const title = document.createElement('p');
            title.textContent = filename;

            const audioElement = document.createElement('audio');
            audioElement.controls = true;
            audioElement.src = audioUrl;
            // No es necesario URL.revokeObjectURL(audioUrl) inmediatamente si quieres que se pueda re-escuchar
            // Se limpiará al recargar la página.

            audioItem.appendChild(title);
            audioItem.appendChild(audioElement);
            audiosDiv.appendChild(audioItem);
        }

         function displayError(filename, message = "Error en el servidor") {
            const errorItem = document.createElement('div');
            errorItem.classList.add('audio-item', 'error'); // Reutilizar clase para estilo
            errorItem.textContent = `Error procesando ${filename}: ${message}`;
            audiosDiv.appendChild(errorItem);
         }


        sendButton.addEventListener('click', connectAndSend);
        updateSelectedFilesList(); // Mostrar estado inicial
    </script>
</body>
</html>